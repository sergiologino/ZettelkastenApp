package com.example.noteapp.service;

import com.example.noteapp.dto.NoteDTO;
import com.example.noteapp.integration.IntegrationException;
import com.example.noteapp.integration.IntegrationService;
import com.example.noteapp.mapper.AbstractConverter;
import com.example.noteapp.model.Note;
import com.example.noteapp.model.Project;
import com.example.noteapp.model.Tag;
import com.example.noteapp.repository.NoteRepository;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.StringUtils;
import org.springframework.web.multipart.MultipartFile;

import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.List;
import java.util.Objects;
import java.util.UUID;
import java.util.stream.Collectors;

@Service
public class NoteService {

    private final AbstractConverter converter;
    private final NoteRepository noteRepository;
    private final TagService tagService;
    private final IntegrationService integrationService;
    private final TelegramService telegramService;
    private final ProjectService projectService;

    public NoteService(AbstractConverter converter, NoteRepository noteRepository, TagService tagService, IntegrationService integrationService, TelegramService telegramService, ProjectService projectService) {
        this.converter = converter;
        this.noteRepository = noteRepository;
        this.tagService = tagService;
        this.integrationService = integrationService;
        this.telegramService = telegramService;
        this.projectService = projectService;
    }

    public List<Note> getAllNotes() {
        return noteRepository.findAll();
    }

    public Note getNoteById(UUID id) {
        return noteRepository.findById(id).orElseThrow(() -> new RuntimeException("Note not found"));
    }

    public Note saveNote(Note note) {
        return noteRepository.save(note);
    }

    public void deleteNoteById(UUID id) {
        noteRepository.deleteById(id);
    }

    public Note addTagsToNote(UUID noteId, List<String> tagNames, boolean isAutoGenerated) {
        Note note = noteRepository.findById(noteId).orElseThrow(() -> new RuntimeException("Note not found"));

        try {
            // Вызываем интеграционный сервис для анализа содержимого
            List<String> autoTags = integrationService.analyzeNoteContent(note.getContent());

            // Присваиваем автоматически сгенерированные теги
            for (String tagName : autoTags) {
                Tag tag = tagService.createTag(tagName, true);
                if (!note.getTags().contains(tag)) { // Избегаем дублирования тегов
                    note.getTags().add(tag);
                }
            }
        } catch (IntegrationException e) {
            // Логируем ошибку и оставляем заметку без изменений
            System.err.println("Ошибка интеграции: " + e.getMessage());
        }

        return noteRepository.save(note);
    }

    public Note moveNoteToProject(UUID noteId, Project project) {
        Note note = noteRepository.findById(noteId).orElseThrow(() -> new RuntimeException("Note not found"));
        note.setProject(project);
        return noteRepository.save(note);
    }

    public Note analyzeAndAssignTags(UUID noteId, String chatId) {
        Note note = noteRepository.findById(noteId).orElseThrow(() -> new RuntimeException("Note not found"));

        // Вызываем интеграционный сервис для анализа содержимого
        List<String> autoTags = integrationService.analyzeNoteContent(note);

        // Присваиваем автоматически сгенерированные теги
        for (String tagName : autoTags) {
            Tag tag = tagService.createTag(tagName, true);
            if (!note.getTags().contains(tag)) { // Избегаем дублирования тегов
                // Реальный текст аннотации
                note.getTags().add(tag);
            }
            note.setAnnotation("Результат анализа");
            String message = "Заметка обработана!\n" +
                    "Ссылка: /api/notes/" + noteId + "\n" +
                    "Аннотация: " + note.getAnnotation() + "\n" +
                    "Теги: " + String.join(", ", autoTags);
            telegramService.sendMessage(chatId, message);
        }
        return noteRepository.save(note);
    }

    public Note addFileToNote(UUID noteId, MultipartFile file, String neuralNetwork) {
        Note note = noteRepository.findById(noteId).orElseThrow(() -> new RuntimeException("Note not found"));

        try {
            // Определяем директорию для сохранения файлов
            String uploadDir = "uploads/";
            Path uploadPath = Paths.get(uploadDir);

            if (!Files.exists(uploadPath)) {
                Files.createDirectories(uploadPath);
            }
            // Генерируем имя файла
            String originalFileName = StringUtils.cleanPath(file.getOriginalFilename());
            String filePath = uploadPath.resolve(originalFileName).toString();
            Files.copy(file.getInputStream(), Paths.get(filePath));

            // Обновляем информацию в заметке
            note.setFilePath(filePath);
            note.setFileType(detectFileType(originalFileName));
            if (neuralNetwork != null) {
                note.setNeuralNetwork(neuralNetwork);
            }
            return noteRepository.save(note);
        } catch (Exception e) {
            throw new RuntimeException("Ошибка при загрузке файла: " + e.getMessage(), e);
        }
    }

    private String detectFileType(String fileName) {
        if (fileName.endsWith(".pdf")) {
            return "pdf";
        } else if (fileName.endsWith(".doc") || fileName.endsWith(".docx")) {
            return "doc";
        } else if (fileName.endsWith(".xls") || fileName.endsWith(".xlsx")) {
            return "xls";
        } else if (fileName.endsWith(".txt")) {
            return "txt";
        } else if (fileName.endsWith(".csv")) {
            return "csv";
        } else if (fileName.endsWith(".jpg") || fileName.endsWith(".jpeg") || fileName.endsWith(".png")) {
            return "image";
        }
        return "unknown";
    }

    public Note addAudioToNote(UUID noteId, MultipartFile file) {
        Note note = noteRepository.findById(noteId).orElseThrow(() -> new RuntimeException("Note not found"));

        try {
            // Определяем директорию для сохранения аудиофайлов
            String uploadDir = "uploads/audio/";
            Path uploadPath = Paths.get(uploadDir);

            if (!Files.exists(uploadPath)) {
                Files.createDirectories(uploadPath);
            }

            // Генерируем имя файла
            String originalFileName = StringUtils.cleanPath(file.getOriginalFilename());
            String filePath = uploadPath.resolve(originalFileName).toString();
            Files.copy(file.getInputStream(), Paths.get(filePath));

            // Обновляем информацию в заметке
            note.setAudioFilePath(filePath);
            return noteRepository.save(note);
        } catch (Exception e) {
            throw new RuntimeException("Ошибка при загрузке аудиофайла: " + e.getMessage(), e);
        }
    }

//    public Note createNote(String content, String fileUrl, String fileName, String project)
    @Transactional
    public Note createNote(Note note){
       // Note note = new Note();
       // note.setContent(content);
        if (note.getUrl() != null && note.getFilePath() != null) {
//            note.setFilePath(fileUrl);
//            note.setFileType(detectFileType(fileName));
        }
        if (note.getProject() == null || note.getProject().getId() == null) {
            note.setProject(projectService.getProjectById(UUID.fromString("3637ff4b-98bc-402b-af00-97bf35f84be3")));
            note.setContent(note.getContent()+" проект добавлен вручную в сервисном методе createNote");
            //throw new IllegalArgumentException("Проект обязателен для создания заметки.");
        }
        noteRepository.save(note);
        System.out.println("body of note entity: " + note);
        // Отправляем на анализ
        if (note.isAnalyze()) {
            try {
                List<String> tags = integrationService.analyzeNoteContent(note);
                // Присваиваем автоматически сгенерированные теги
                for (String tagName : tags) {
                    Tag tag = tagService.createTag(tagName, true);
                    if (!note.getTags().contains(tag)) { // Избегаем дублирования тегов
                        note.getTags().add(tag);
                    }
                }
            } catch (Exception e) {
                // Логируем ошибку, но не прерываем процесс
                System.err.println("Ошибка при анализе заметки: " + e.getMessage());
                noteRepository.save(note);


            }
        }
        return note;
    }
    public Note analyzeGroupNotes(List<UUID> noteIds, String chatId) {
        List<Note> notes = noteRepository.findAllById(noteIds);

        if (notes.isEmpty()) {
            throw new RuntimeException("No notes found for provided IDs.");
        }

        // Собираем данные для анализа
        String combinedContent = notes.stream()
                .map(Note::getContent)
                .filter(Objects::nonNull)
                .collect(Collectors.joining("\n\n"));

        // Отправляем на анализ
        String annotation = integrationService.analyzeGroupContent(combinedContent);
        List<String> autoTagNames = integrationService.extractTags(annotation);

        List<Tag> autoTags = autoTagNames.stream()
                .map(tagName -> tagService.createTag(tagName, true))
                .collect(Collectors.toList());

        // Создаем групповую заметку
        Note groupNote = new Note();
        groupNote.setContent("Групповая заметка: \n\n" + combinedContent);
        groupNote.setAnnotation(annotation);
        groupNote.setTags(autoTags);
        groupNote.setAiSummary(true);

        noteRepository.save(groupNote);

        // Отправляем результат в Telegram
        String message = "Групповая обработка завершена!\n" +
                "Ссылка: /api/notes/" + groupNote.getId() + "\n" +
                "Аннотация: " + annotation + "\n" +
                "Теги: " + autoTags.stream().map(Tag::getName).collect(Collectors.joining(", "));
        telegramService.sendMessage(chatId, message);

        return groupNote;
    }

    public Note analyzeProjectNotes(UUID projectId, String chatId) {
        List<Note> notes = noteRepository.findAllByProjectId(projectId);

        if (notes.isEmpty()) {
            throw new RuntimeException("No notes found for project ID: " + projectId);
        }

        // Собираем данные для анализа
        String combinedContent = notes.stream()
                .map(Note::getContent)
                .filter(Objects::nonNull)
                .collect(Collectors.joining("\n\n"));

        // Отправляем на анализ
        String annotation = integrationService.analyzeGroupContent(combinedContent);
        List<String> autoTagNames  = integrationService.extractTags(annotation);

        List<Tag> autoTags = autoTagNames.stream()
                .map(tagName -> tagService.createTag(tagName, true))
                .collect(Collectors.toList());

        // Создаем групповую заметку
        Note projectGroupNote = new Note();
        projectGroupNote.setContent("Групповая заметка проекта: \n\n" + combinedContent);
        projectGroupNote.setAnnotation(annotation);
        projectGroupNote.setTags(autoTags);
        projectGroupNote.setAiSummary(true);

        noteRepository.save(projectGroupNote);

        // Отправляем результат в Telegram
        String message = "Обработка заметок проекта завершена!\n" +
                "Ссылка: /api/notes/" + projectGroupNote.getId() + "\n" +
                "Аннотация: " + annotation + "\n" +
                "Теги: " + autoTags.stream().map(Tag::getName).collect(Collectors.joining(", "));
        telegramService.sendMessage(chatId, message);

        return projectGroupNote;
    }

}
