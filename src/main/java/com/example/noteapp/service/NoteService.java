package com.example.noteapp.service;

import com.example.noteapp.dto.NoteAudioDTO;
import com.example.noteapp.dto.NoteDTO;
import com.example.noteapp.dto.NoteFileDTO;
import com.example.noteapp.integration.IntegrationException;
import com.example.noteapp.integration.IntegrationService;
import com.example.noteapp.mapper.AbstractConverter;
//import com.example.noteapp.mapper.NoteConverter;
import com.example.noteapp.model.*;
import com.example.noteapp.repository.NoteRepository;
import com.example.noteapp.repository.OpenGraphDataRepository;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.StringUtils;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.*;
import java.util.stream.Collectors;

import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.select.Elements;

@Service
public class NoteService {

    @Value("${file.storage-path}")
    private String fileStoragePath;

    @Value("${audio.storage-path}")
    private String audioStoragePath;

    @Value("${open-graph-data.enabled}")
    private boolean openGraphDataEnabled;


    private final NoteRepository noteRepository;
    private final TagService tagService;
    private final IntegrationService integrationService;
    private final TelegramService telegramService;
    private final ProjectService projectService;
  //  private final NoteConverter noteConverter;
    private final OpenGraphDataRepository openGraphDataRepository;
    private final String filePath = "${file.storage-path}";
    private final String audioFilePath = "${audio.storage-path}";


    public NoteService( NoteRepository noteRepository, TagService tagService, IntegrationService integrationService, TelegramService telegramService, ProjectService projectService, OpenGraphDataRepository openGraphDataRepository) {

        this.noteRepository = noteRepository;
        this.tagService = tagService;
        this.integrationService = integrationService;
        this.telegramService = telegramService;
        this.projectService = projectService;
       // this.noteConverter = noteConverter;
        this.openGraphDataRepository = openGraphDataRepository;
    }

    public List<Note> getAllNotes() {
        return noteRepository.findAll();
    }

    public Note getNoteById(UUID id) {
        return noteRepository.findById(id).orElseThrow(() -> new RuntimeException("Note not found"));
    }

    public Note saveNote(Note note) {
        return noteRepository.save(note);
    }

    public void deleteNoteById(UUID id) {
        noteRepository.deleteById(id);
    }

    public Note addTagsToNote(UUID noteId, List<String> tagNames, boolean isAutoGenerated) {
        Note note = noteRepository.findById(noteId).orElseThrow(() -> new RuntimeException("Note not found"));

        try {
            // Вызываем интеграционный сервис для анализа содержимого
            List<String> autoTags = integrationService.analyzeNoteContent(note.getContent());

            // Присваиваем автоматически сгенерированные теги
            for (String tagName : autoTags) {
                Tag tag = tagService.createTag(tagName, true);
                if (!note.getTags().contains(tag)) { // Избегаем дублирования тегов
                    note.getTags().add(tag);
                }
            }
        } catch (IntegrationException e) {
            // Логируем ошибку и оставляем заметку без изменений
            System.err.println("Ошибка интеграции: " + e.getMessage());
        }

        return noteRepository.save(note);
    }

    public Note moveNoteToProject(UUID noteId, Project project) {
        Note note = noteRepository.findById(noteId).orElseThrow(() -> new RuntimeException("Note not found"));
        note.setProject(project);
        return noteRepository.save(note);
    }

    public Note analyzeAndAssignTags(UUID noteId, String chatId) {
        Note note = noteRepository.findById(noteId).orElseThrow(() -> new RuntimeException("Note not found"));

        // Вызываем интеграционный сервис для анализа содержимого
        List<String> autoTags = integrationService.analyzeNoteContent(note);

        // Присваиваем автоматически сгенерированные теги
        for (String tagName : autoTags) {
            Tag tag = tagService.createTag(tagName, true);
            if (!note.getTags().contains(tag)) { // Избегаем дублирования тегов
                // Реальный текст аннотации
                note.getTags().add(tag);
            }
            note.setAnnotation("Результат анализа");
            String message = "Заметка обработана!\n" +
                    "Ссылка: /api/notes/" + noteId + "\n" +
                    "Аннотация: " + note.getAnnotation() + "\n" +
                    "Теги: " + String.join(", ", autoTags);
            telegramService.sendMessage(chatId, message);
        }
        return noteRepository.save(note);
    }

    public Note addFileToNote(UUID noteId, MultipartFile file, String neuralNetwork) {
        Note note = noteRepository.findById(noteId).orElseThrow(() -> new RuntimeException("Note not found"));

        try {
            // Определяем директорию для сохранения файлов
            String uploadDir = "uploads/";
            Path uploadPath = Paths.get(uploadDir);

            if (!Files.exists(uploadPath)) {
                Files.createDirectories(uploadPath);
            }
            // Генерируем имя файла
            String originalFileName = StringUtils.cleanPath(file.getOriginalFilename());
            String filePath = uploadPath.resolve(originalFileName).toString();
            Files.copy(file.getInputStream(), Paths.get(filePath));

            // Обновляем информацию в заметке
            note.setFilePath(filePath);
            note.setFileType(detectFileType(originalFileName));
            if (neuralNetwork != null) {
                note.setNeuralNetwork(neuralNetwork);
            }
            return noteRepository.save(note);
        } catch (Exception e) {
            throw new RuntimeException("Ошибка при загрузке файла: " + e.getMessage(), e);
        }
    }

    private String detectFileType(String fileName) {
        if (fileName.endsWith(".pdf")) {
            return "pdf";
        } else if (fileName.endsWith(".doc") || fileName.endsWith(".docx")) {
            return "doc";
        } else if (fileName.endsWith(".xls") || fileName.endsWith(".xlsx")) {
            return "xls";
        } else if (fileName.endsWith(".txt")) {
            return "txt";
        } else if (fileName.endsWith(".csv")) {
            return "csv";
        } else if (fileName.endsWith(".jpg") || fileName.endsWith(".jpeg") || fileName.endsWith(".png")) {
            return "image";
        }
        return "unknown";
    }

    public Note addAudioToNote(UUID noteId, MultipartFile file) {
        Note note = noteRepository.findById(noteId).orElseThrow(() -> new RuntimeException("Note not found"));

        try {
            // Определяем директорию для сохранения аудиофайлов
            String uploadDir = "uploads/audio/";
            Path uploadPath = Paths.get(uploadDir);

            if (!Files.exists(uploadPath)) {
                Files.createDirectories(uploadPath);
            }

            // Генерируем имя файла
            String originalFileName = StringUtils.cleanPath(file.getOriginalFilename());
            String filePath = uploadPath.resolve(originalFileName).toString();
            Files.copy(file.getInputStream(), Paths.get(filePath));

            // Обновляем информацию в заметке
            note.setAudioFilePath(filePath);
            return noteRepository.save(note);
        } catch (Exception e) {
            throw new RuntimeException("Ошибка при загрузке аудиофайла: " + e.getMessage(), e);
        }
    }

    @Transactional
    public Note updateNote(Note note, List<String> links) {
//        Note existedNote = noteRepository.findById(note.getId()).orElseThrow(() -> new RuntimeException("Note not found"));
//        List<OpenGraphData> existingData = note.getOpenGraphData() != null ? note.getOpenGraphData() : new ArrayList<>();

        boolean useOpenGraph = openGraphDataEnabled;
        if (useOpenGraph) {
            if (links != null && !links.isEmpty()) {
                // Получаем текущую коллекцию
                List<OpenGraphData> existingData = openGraphDataRepository.findByNoteId(note.getId());

                // Удаляем существующие элементы, которые не соответствуют новым ссылкам
                existingData.removeIf(data -> !links.contains(data.getUrl()));

                // Добавляем новые OpenGraph данные
                List<String> existingUrls = existingData.stream()
                        .map(OpenGraphData::getUrl)
                        .collect(Collectors.toList());
                links.stream()
                        .filter(link -> !existingUrls.contains(link))
                        .map(link -> fetchOpenGraphData(link, note))
                        .filter(Objects::nonNull)
                        .forEach(existingData::add); // Добавляем в существующую коллекцию

                System.out.println("existingData содержит: " + existingData); // проверяем что получилось в existingData

                // Добавляем данные в объект Note
                note.getOpenGraphData().addAll(existingData);

                // Сохраняем данные в базу через репозиторий
                openGraphDataRepository.saveAll(existingData);

            }
        }
        noteRepository.save(note);

        return note;

    }


    @Transactional
    public Note createNote(Note note, List<String> links){
//
        if (note.getProject() == null || note.getProject().getId() == null) {
            note.setProject(projectService.getProjectById(UUID.fromString("3637ff4b-98bc-402b-af00-97bf35f84be3")));
            note.setContent(note.getContent()+" проект добавлен костылем в createNote");
            //throw new IllegalArgumentException("Проект обязателен для создания заметки.");
        }
        noteRepository.save(note);
        // Обрабатываем ссылки и сохраняем Open Graph данные
        boolean useOpenGraph = openGraphDataEnabled;
        if (useOpenGraph) {
            if (links != null && !links.isEmpty()) {
                // Получаем текущую коллекцию
                List<OpenGraphData> existingData = openGraphDataRepository.findByNoteId(note.getId());

                // Удаляем существующие элементы, которые не соответствуют новым ссылкам
                existingData.removeIf(data -> !links.contains(data.getUrl()));

                // Добавляем новые OpenGraph данные
                List<String> existingUrls = existingData.stream()
                        .map(OpenGraphData::getUrl)
                        .collect(Collectors.toList());
                links.stream()
                        .filter(link -> !existingUrls.contains(link))
                        .map(link -> fetchOpenGraphData(link, note))
                        .filter(Objects::nonNull)
                        .forEach(existingData::add); // Добавляем в существующую коллекцию

                System.out.println("existingData содержит: " + existingData); // проверяем что получилось в existingData

                // Добавляем данные в объект Note
                note.getOpenGraphData().addAll(existingData);

                // Сохраняем данные в базу через репозиторий
                openGraphDataRepository.saveAll(existingData);

            }


            System.out.println("OpenGraphData после обработки: " + note.getOpenGraphData());
            return noteRepository.save(note);

        }
        return note;


        //TODO временно, чтобы не отправлять на анализ, потом убрать, правильная есть в конце метода
        // Отправляем на анализ
//        if (note.isAnalyze()) {
//            try {
//                List<String> tags = integrationService.analyzeNoteContent(note);
//                // Присваиваем автоматически сгенерированные теги
//                for (String tagName : tags) {
//                    Tag tag = tagService.createTag(tagName, true);
//                    if (!note.getTags().contains(tag)) { // Избегаем дублирования тегов
//                        note.getTags().add(tag);
//                    }
//                }
//            } catch (Exception e) {
//                // Логируем ошибку, но не прерываем процесс
//                System.err.println("Ошибка при анализе заметки: " + e.getMessage());
//                noteRepository.save(note);
//
//
//            }
//        }
//        return note;
    }



    private OpenGraphData fetchOpenGraphData(String url, Note note) {
        try {
            Document document = Jsoup.connect(url).get();
            OpenGraphData ogData = new OpenGraphData();
            ogData.setUrl(url);
            ogData.setTitle(getMetaTagContent(document, "og:title"));
            ogData.setDescription(getMetaTagContent(document, "og:description"));
            ogData.setImage(getMetaTagContent(document, "og:image"));
            ogData.setNote(note);
            System.err.println("graphData:"+ogData);
            return ogData;
        } catch (IOException e) {
            System.err.println("Ошибка при обработке Open Graph: " + url);
            e.printStackTrace(); // Добавлено для отладки
            return null;
        }
    }

    public Map<String, OpenGraphData> processOpenGraphData(List<String> links) {
        Map<String, OpenGraphData> openGraphDataMap = new HashMap<>();

        for (String link : links) {
            try {
                Document document = Jsoup.connect(link).get();
                OpenGraphData ogData = new OpenGraphData();

                ogData.setTitle(getMetaTagContent(document, "og:title"));
                ogData.setDescription(getMetaTagContent(document, "og:description"));
                ogData.setImage(getMetaTagContent(document, "og:image"));
                ogData.setUrl(link);

                openGraphDataMap.put(link, ogData);
            } catch (IOException e) {
                // Логируем ошибку, если невозможно обработать ссылку
                System.err.println("Ошибка при обработке ссылки: " + link + " - " + e.getMessage());
            }
        }

        return openGraphDataMap;
    }

    private String getMetaTagContent(Document document, String metaName) {
        return document.select("meta[property=" + metaName + "]").attr("content");
    }




    public Note analyzeGroupNotes(List<UUID> noteIds, String chatId) {
        List<Note> notes = noteRepository.findAllById(noteIds);

        if (notes.isEmpty()) {
            throw new RuntimeException("No notes found for provided IDs.");
        }

        // Собираем данные для анализа
        String combinedContent = notes.stream()
                .map(Note::getContent)
                .filter(Objects::nonNull)
                .collect(Collectors.joining("\n\n"));

        // Отправляем на анализ
        String annotation = integrationService.analyzeGroupContent(combinedContent);
        List<String> autoTagNames = integrationService.extractTags(annotation);

        List<Tag> autoTags = autoTagNames.stream()
                .map(tagName -> tagService.createTag(tagName, true))
                .collect(Collectors.toList());

        // Создаем групповую заметку
        Note groupNote = new Note();
        groupNote.setContent("Групповая заметка: \n\n" + combinedContent);
        groupNote.setAnnotation(annotation);
        groupNote.setTags(autoTags);
        groupNote.setAiSummary(true);

        noteRepository.save(groupNote);

        // Отправляем результат в Telegram
        if(!chatId.isEmpty()){

                String message = "Групповая обработка завершена!\n" +
                        "Ссылка: /api/notes/" + groupNote.getId() + "\n" +
                        "Аннотация: " + annotation + "\n" +
                        "Теги: " + autoTags.stream().map(Tag::getName).collect(Collectors.joining(", "));
                telegramService.sendMessage(chatId, message);
        }

        return groupNote;
    }

    public Note analyzeProjectNotes(UUID projectId, String chatId) {
        List<Note> notes = noteRepository.findAllByProjectId(projectId);

        if (notes.isEmpty()) {
            throw new RuntimeException("No notes found for project ID: " + projectId);
        }

        // Собираем данные для анализа
        String combinedContent = notes.stream()
                .map(Note::getContent)
                .filter(Objects::nonNull)
                .collect(Collectors.joining("\n\n"));

        // Отправляем на анализ
        String annotation = integrationService.analyzeGroupContent(combinedContent);
        List<String> autoTagNames  = integrationService.extractTags(annotation);

        List<Tag> autoTags = autoTagNames.stream()
                .map(tagName -> tagService.createTag(tagName, true))
                .collect(Collectors.toList());

        // Создаем групповую заметку
        Note projectGroupNote = new Note();
        projectGroupNote.setContent("Групповая заметка проекта: \n\n" + combinedContent);
        projectGroupNote.setAnnotation(annotation);
        projectGroupNote.setTags(autoTags);
        projectGroupNote.setAiSummary(true);

        noteRepository.save(projectGroupNote);

        // Отправляем результат в Telegram
        String message = "Обработка заметок проекта завершена!\n" +
                "Ссылка: /api/notes/" + projectGroupNote.getId() + "\n" +
                "Аннотация: " + annotation + "\n" +
                "Теги: " + autoTags.stream().map(Tag::getName).collect(Collectors.joining(", "));
        telegramService.sendMessage(chatId, message);

        return projectGroupNote;
    }

    public List<Note> getNotesByProjectId(UUID projectId) {
        List<Note> foundedNotes = noteRepository.findAllByProjectId(projectId);
//        for (Note note : foundedNotes) {
//            note.setProject(projectService.getProjectById(note.getProject().getId()));
//        }
        for (Note note : foundedNotes) {
            note.setAudios(noteRepository.findAudiosByNoteId(note.getId()));
            note.setFiles(noteRepository.findFilesByNoteId(note.getId()));
        }
        return foundedNotes;
    }

    public List<Tag> getTagsByNoteId(UUID noteId) { return noteRepository.findTagsByNoteId(noteId); }

    public List<Tag> getTagsByName(List<String> tags) {
        List<Tag> tagList = new ArrayList<>();
        for (String tagName : tags) {
            Tag tag = tagService.findOrCreateTag(tagName, false);
            tagList.add(tag);
        }
        return tagList;
    }



    public List<String> getUrlsByNoteId (Note note){
        return openGraphDataRepository.findUrlsByNoteId(note.getId());
    }

    public OpenGraphData getOpenGraphDataByUrl(String url) {
        System.out.println("Получен URL для поиска: " + url);
        return openGraphDataRepository.findByUrl(url).stream().findFirst()
                .orElseThrow(() -> new RuntimeException("OpenGraphData not found for URL: " + url));
    }

    public List<OpenGraphData> getOpenGraphDataForNote(UUID noteId) {

          return openGraphDataRepository.findByNoteId(noteId);
    }

    @Transactional
    public Note addFilesToNote(UUID noteId, List<MultipartFile> files) {
        Note note = noteRepository.findById(noteId).orElseThrow(() -> new RuntimeException("Note not found"));

        for (MultipartFile file : files) {
            try {
                // TODO временно дляч теста ставлю абсолютный путь
                String uploadDir = "E:/uploaded/uploaded-files/";
                Path uploadPath = Paths.get(uploadDir);

                if (!Files.exists(uploadPath)) {
                    Files.createDirectories(uploadPath);
                }

                // Уникальное имя файла
                String originalFileName = StringUtils.cleanPath(file.getOriginalFilename());
                String uniqueFileName = UUID.randomUUID().toString() + "_" + originalFileName;

                Path filePath = uploadPath.resolve(uniqueFileName);
                Files.copy(file.getInputStream(), filePath);

                System.out.println("Оригинальное имя файла: " + file.getOriginalFilename());
                System.out.println("Директория загрузки: " + uploadDir);
                System.out.println("Уникальное имя файла: " + uniqueFileName);



                Files.copy(file.getInputStream(), Paths.get(filePath.toUri()),StandardCopyOption.REPLACE_EXISTING);

                // Сохранение информации о файле
                note.setFilePath(filePath.toString());
                note.setFileType(detectFileType(originalFileName));

                NoteFile newNoteFile = new NoteFile();
                newNoteFile.setFileName(originalFileName);
                newNoteFile.setFilePath(filePath.toString());
                newNoteFile.setNote(note);
                noteRepository.save(note);


                List<NoteFile> newFileList = note.getFiles();
                newFileList.add(newNoteFile);
                note.setFiles(newFileList);



            } catch (IOException e) {
                throw new RuntimeException("Ошибка при загрузке файла: " + e.getMessage(), e);
            }
        }
        //UUID id, String filePath, String fileName, Note note

        return noteRepository.save(note);
    }

    @Transactional
    public Note addAudiosToNote(UUID noteId, List<MultipartFile> audios) {
        Note note = noteRepository.findById(noteId).orElseThrow(() -> new RuntimeException("Note not found"));
        if(audios.isEmpty() || audios ==null){
            System.out.println("audios not present in endpoint");
        }
        System.out.println("Аудиофайл на входе: " + audios.toString());
        System.out.println("Размер аудиофайла: " + audios.size());

        for (MultipartFile audio : audios) {
            try {
                // TODO временно дляч теста ставлю абсолютный путь
                String uploadDir = "E:/uploaded/uploaded-audio/";
                //String uploadDir = audioStoragePath;
                Path uploadPath = Paths.get(uploadDir);

                if (!Files.exists(uploadPath)) {
                    Files.createDirectories(uploadPath);
                }

                String originalFileName = StringUtils.cleanPath(Objects.requireNonNull(audio.getOriginalFilename()));
                String uniqueFileName = UUID.randomUUID().toString() + "_" + originalFileName;

                Path filePath = uploadPath.resolve(uniqueFileName);

                System.out.println("Оригинальное имя аудиофайла: " + audio.getOriginalFilename());
                System.out.println("Директория загрузки аудиофайла: " + uploadDir);
                System.out.println("Уникальное имя файла аудиофайла: " + uniqueFileName);

                Files.copy(audio.getInputStream(), Paths.get(filePath.toUri()), StandardCopyOption.REPLACE_EXISTING);



                // Сохранение информации о файле
//                note.setFilePath(filePath.toString()); // Можно расширить для работы с несколькими файлами
//                note.setFileType(detectFileType(originalFileName));

                NoteAudio newNoteAudioFile = new NoteAudio();
                newNoteAudioFile.setAudioFileName(originalFileName+".mp3");
                newNoteAudioFile.setAudioFilePath(filePath.toString());
                newNoteAudioFile.setNote(note);
                noteRepository.save(note);


                List<NoteAudio> newAudioFileList = note.getAudios();

                // TODO перенести за пределы цикла, переделать сбор аудио
                newAudioFileList.add(newNoteAudioFile);




            } catch (IOException e) {
                throw new RuntimeException("Ошибка при загрузке файла: " + e.getMessage(), e);
            }
        }

        return noteRepository.save(note);
    }

    private String downloadFile(String fileUrl, String storagePath, String fileName) {
        try {
            Path storageDirectory = Paths.get(storagePath);
            Path destinationPath = storageDirectory.resolve(fileName);
            Files.copy(new URL(fileUrl).openStream(), destinationPath, StandardCopyOption.REPLACE_EXISTING);
            return destinationPath.toString();
        } catch (IOException e) {
            throw new RuntimeException("Failed to download file: " + fileUrl, e);
        }
    }

    @Transactional
    public Note updateNoteCoordinates(UUID noteId, Long x, Long y) {
        Note note = noteRepository.findById(noteId)
                .orElseThrow(() -> new RuntimeException("Note not found"));
        note.setPositionX(x);
        note.setPositionY(y);
        return noteRepository.save(note);
    }


}
