package com.example.noteapp.service;

import com.example.noteapp.model.Tag;
import com.example.noteapp.repository.TagRepository;
import com.example.noteapp.repository.UserRepository;
import com.example.noteapp.utils.SecurityUtils;
import jakarta.persistence.EntityNotFoundException;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

@Service
public class TagService {

    private final TagRepository tagRepository;
    private final UserRepository userRepository;

    public TagService(TagRepository tagRepository, UserRepository userRepository) {
        this.tagRepository = tagRepository;
        this.userRepository = userRepository;
    }

    // Получение текущего userId
    private UUID getCurrentUserId() {
        return userRepository.findByUsername(SecurityUtils.getCurrentUserId()).getId();
    }

    public List<Tag> getAllTags() {

        UUID userId = getCurrentUserId();
        return tagRepository.findAllByUserId(userId);
    }

    public Tag createTag(String name, boolean isAutoGenerated) {
        UUID userId = getCurrentUserId();

        // Проверяем, существует ли уже тег с таким именем у текущего пользователя
        Optional<Tag> existingTag = tagRepository.findByNameAndUserId(name, userId);
        if (existingTag.isPresent()) {
            return existingTag.get(); // Возвращаем существующий тег
        }
        // Создаем новый тег
        Tag tag = new Tag();
        tag.setName(name);
        tag.setAutoGenerated(isAutoGenerated);
        tag.setUserId(userId); // Устанавливаем пользователя для тега
        return tagRepository.save(tag);
    }

    public void deleteTagById(UUID id) {
        UUID userId = getCurrentUserId();
        Tag tag = tagRepository.findByIdAndUserId(id, userId)
                .orElseThrow(() -> new EntityNotFoundException("Tag not found or access denied."));
        tagRepository.delete(tag);
    }

    public Tag getTagByName(String name) {
        UUID userId = getCurrentUserId();
        return tagRepository.findByNameAndUserId(name, userId)
                .orElseThrow(() -> new EntityNotFoundException("Tag not found or access denied."));

    }

    public String tagName(Tag tag) {
        return tag.getName();
    }
    public List<String> tagNameList(List<Tag> tags) {
        List<String> tagNames = new ArrayList<>();
        for (Tag tag : tags) {
            tagNames.add(tag.getName());
        }
        return tagNames;
    }

    public Tag findOrCreateTag(String tagName, boolean isAutoGenerated) {
        UUID userId = getCurrentUserId();

        // Проверяем, существует ли уже тег с таким именем у текущего пользователя
        Optional<Tag> existingTag = tagRepository.findByNameAndUserId(tagName, userId);
        if (existingTag.isPresent()) {
            return existingTag.get(); // Возвращаем существующий тег
        }

        // Создаем новый тег
        Tag tag = new Tag();
        tag.setName(tagName);
        tag.setAutoGenerated(isAutoGenerated);
        tag.setUserId(userId); // Устанавливаем userId для нового тега
        return tagRepository.save(tag);
    }

    public Tag findOrCreateTagForBot(String tagName, boolean isAutoGenerated, UUID userId) {

        // Проверяем, существует ли уже тег с таким именем у текущего пользователя
        Optional<Tag> existingTag = tagRepository.findByNameAndUserId(tagName, userId);
        if (existingTag.isPresent()) {
            return existingTag.get(); // Возвращаем существующий тег
        }

        // Создаем новый тег
        Tag tag = new Tag();
        tag.setName(tagName);
        tag.setAutoGenerated(isAutoGenerated);
        tag.setUserId(userId); // Устанавливаем userId для нового тега
        return tagRepository.save(tag);
    }

    public List<Tag> getTagsByName(List<String> tagNames) {
        UUID userId = getCurrentUserId();

        // Получаем теги по именам только для текущего пользователя
        return tagNames.stream()
                .map(tagName -> findOrCreateTag(tagName, false)) // Используем findOrCreateTag для каждого имени
                .toList();
    }
    public List<Tag> getTagsByNameAndUserId(List<String> tagNames, UUID userId) {
//        UUID userId = getCurrentUserId();

        // Получаем теги по именам только для текущего пользователя
        return tagNames.stream()
                .map(tagName -> findOrCreateTagForBot(tagName, false, userId)) // Используем findOrCreateTag для каждого имени
                .toList();
    }
    //

    public List<Tag> getTagsByNameForBot(List<String> tagNames, UUID userId) {
                // Получаем теги по именам только для текущего пользователя
        return tagNames.stream()
                .map(tagName -> findOrCreateTagForBot(tagName, false, userId)) // Используем findOrCreateTag для каждого имени
                .toList();
    }

}

